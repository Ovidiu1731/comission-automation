/**
 * Team Leader Commission Processing
 * 
 * Calculates Team Leader commissions based on sales generated by Setters and Callers.
 * - George Coapsi (Team Leader Setteri): 5% of all Setter-generated sales
 * - Alexandru Prisiceanu (Team Leader Calleri): 2% of all Caller-generated sales
 * 
 * Commissions are calculated from "Total După TVA" (amount without VAT).
 */
import {
  getSetterCallerSales,
  findRepresentativeByFuzzyName,
  getExpenseByExpenseId,
  createExpense,
  updateExpense
} from './airtableService.js';
import {
  FIELDS,
  EXPENSE_TYPES,
  VAT_INCLUDED,
  SOURCE,
  TEAM_LEADERS,
  SETTER_CALLER_NAME_REGEX,
  getCurrentRomanianMonth,
  getCurrentYear,
  getCurrentMonthYearString
} from '../config/constants.js';
import {
  isValidExpenseAmount,
  isValidProject
} from '../utils/validators.js';
import { logger } from '../utils/logger.js';

/**
 * Extract CamelCase name from Utm Campaign field
 * Handles various formats: "Name", "Name - Extra", "Name Extra"
 */
function extractNameFromUtmCampaign(utmCampaign) {
  if (!utmCampaign) return null;
  
  // Split by common delimiters and take the first part
  const parts = utmCampaign.split(/[-–—\s]+/);
  const name = parts[0].trim();
  
  // Validate CamelCase format (e.g., "ValentinDragomir")
  if (SETTER_CALLER_NAME_REGEX.test(name)) {
    return name;
  }
  
  return null;
}

/**
 * Process all Team Leader commissions for current month
 */
export async function processTeamLeaderCommissions() {
  const month = getCurrentRomanianMonth();
  const year = getCurrentYear();
  const monthYear = getCurrentMonthYearString();
  
  logger.info('=== Processing Team Leader Commissions ===');
  logger.info('Month:', month);
  logger.info('Year:', year);
  
  const stats = {
    processed: 0,
    setterSales: 0,
    callerSales: 0,
    skipped: 0,
    created: 0,
    updated: 0,
    errors: 0,
    georgeCoapsiTotal: 0,
    alexandruPrisiceanuTotal: 0
  };
  
  try {
    // Fetch all sales for current month with Setter/Caller commission
    const sales = await getSetterCallerSales(monthYear);
    
    if (sales.length === 0) {
      logger.info('No sales with Setter/Caller commission found for Team Leader processing', { month });
      return stats;
    }
    
    logger.info(`Fetched ${sales.length} sales with Setter/Caller commission`);
    
    // Process each sale to determine Team Leader commission
    const teamLeaderCommissions = [];
    const roleCache = {}; // Cache role lookups
    
    for (const sale of sales) {
      stats.processed++;
      
      // Extract name from Utm Campaign
      const name = extractNameFromUtmCampaign(sale.utmCampaign);
      
      if (!name) {
        logger.debug('Skipping sale - invalid or missing name in Utm Campaign', {
          saleId: sale.id,
          utmCampaign: sale.utmCampaign
        });
        stats.skipped++;
        continue;
      }
      
      // Validate amount
      if (!sale.amountWithoutVat || sale.amountWithoutVat <= 0) {
        logger.debug('Skipping sale - invalid amount without VAT', {
          saleId: sale.id,
          amountWithoutVat: sale.amountWithoutVat
        });
        stats.skipped++;
        continue;
      }
      
      // Validate project
      if (!isValidProject(sale.project)) {
        logger.debug('Skipping sale - invalid or missing project', {
          saleId: sale.id,
          project: sale.project
        });
        stats.skipped++;
        continue;
      }
      
      // Look up representative role (with cache)
      let role = roleCache[name];
      if (!role) {
        const rep = await findRepresentativeByFuzzyName(name);
        if (!rep) {
          logger.warn(`Person ${name} not found in Reprezentanți table, skipping sale ${sale.id}`);
          stats.skipped++;
          continue;
        }
        
        // Role can be array or single value
        const roles = Array.isArray(rep.role) ? rep.role : [rep.role];
        
        // Determine if Setter or Caller
        if (roles.includes('Setter')) {
          role = 'Setter';
        } else if (roles.includes('Caller')) {
          role = 'Caller';
        } else {
          logger.debug(`Person ${name} has role ${roles.join(', ')} - not Setter or Caller, skipping`, {
            saleId: sale.id
          });
          stats.skipped++;
          continue;
        }
        
        roleCache[name] = role;
        logger.debug(`Cached role for ${name}: ${role}`);
      }
      
      // Calculate Team Leader commission based on role
      let teamLeaderConfig;
      if (role === 'Setter') {
        teamLeaderConfig = TEAM_LEADERS.SETTER;
        stats.setterSales++;
      } else if (role === 'Caller') {
        teamLeaderConfig = TEAM_LEADERS.CALLER;
        stats.callerSales++;
      } else {
        stats.skipped++;
        continue;
      }
      
      const commission = sale.amountWithoutVat * teamLeaderConfig.commissionRate;
      
      logger.debug('Calculated Team Leader commission', {
        saleId: sale.id,
        name,
        role,
        teamLeader: teamLeaderConfig.name,
        amountWithoutVat: sale.amountWithoutVat,
        rate: teamLeaderConfig.commissionRate,
        commission
      });
      
      // Track totals
      if (role === 'Setter') {
        stats.georgeCoapsiTotal += commission;
      } else {
        stats.alexandruPrisiceanuTotal += commission;
      }
      
      teamLeaderCommissions.push({
        saleId: sale.id,
        project: sale.project,
        teamLeaderName: teamLeaderConfig.name,
        teamLeaderType: role, // 'Setter' or 'Caller'
        category: teamLeaderConfig.category,
        commission,
        amountWithoutVat: sale.amountWithoutVat
      });
    }
    
    logger.info('Team Leader commission calculation complete', {
      totalSales: sales.length,
      processed: stats.processed,
      setterSales: stats.setterSales,
      callerSales: stats.callerSales,
      skipped: stats.skipped,
      georgeCoapsiTotal: stats.georgeCoapsiTotal.toFixed(2),
      alexandruPrisiceanuTotal: stats.alexandruPrisiceanuTotal.toFixed(2)
    });
    
    // Group by Team Leader and Project
    const grouped = groupCommissionsByTeamLeaderAndProject(teamLeaderCommissions);
    
    logger.info(`Grouped into ${grouped.length} Team Leader + Project combinations`);
    
    // Create/update expense records
    for (const group of grouped) {
      try {
        await createOrUpdateTeamLeaderExpense(group, month, year);
        stats.created++; // Will be adjusted in the function if updated
      } catch (error) {
        logger.error('Failed to create/update Team Leader expense', {
          error: error.message,
          group
        });
        stats.errors++;
      }
    }
    
    logger.info('=== Team Leader Commission Processing Complete ===', stats);
    
    return stats;
  } catch (error) {
    logger.error('Team Leader commission processing failed', {
      error: error.message,
      stack: error.stack
    });
    throw error;
  }
}

/**
 * Group Team Leader commissions by Team Leader and Project
 */
function groupCommissionsByTeamLeaderAndProject(commissions) {
  const groups = {};
  
  for (const comm of commissions) {
    const key = `${comm.teamLeaderName}_${comm.project}`;
    
    if (!groups[key]) {
      groups[key] = {
        teamLeaderName: comm.teamLeaderName,
        teamLeaderType: comm.teamLeaderType,
        category: comm.category,
        project: comm.project,
        totalCommission: 0,
        salesCount: 0,
        saleIds: []
      };
    }
    
    groups[key].totalCommission += comm.commission;
    groups[key].salesCount++;
    groups[key].saleIds.push(comm.saleId);
  }
  
  return Object.values(groups);
}

/**
 * Create or update Team Leader expense record
 */
async function createOrUpdateTeamLeaderExpense(group, month, year) {
  const { teamLeaderName, teamLeaderType, category, project, totalCommission, salesCount, saleIds } = group;
  
  // Round commission to 2 decimals
  const roundedCommission = Math.round(totalCommission * 100) / 100;
  
  // Validate commission amount
  if (!isValidExpenseAmount(roundedCommission)) {
    logger.warn('Invalid Team Leader commission amount, skipping', {
      teamLeaderName,
      project,
      commission: roundedCommission
    });
    return;
  }
  
  // Generate unique expense ID: team_leader_{type}_{project}_{month}
  const expenseId = `team_leader_${teamLeaderType.toLowerCase()}_${project}_${month}`
    .replace(/\s+/g, '_');
  
  // Prepare expense data
  const expenseFields = {
    [FIELDS.EXPENSE_DESCRIPTION]: `Comision Team Leader ${teamLeaderType} - ${teamLeaderName} (${salesCount} vanzari)`,
    [FIELDS.EXPENSE_TYPE]: EXPENSE_TYPES.COMMISSIONS,
    [FIELDS.EXPENSE_PROJECT]: project,
    [FIELDS.EXPENSE_CATEGORY]: category,
    [FIELDS.EXPENSE_AMOUNT]: roundedCommission,
    [FIELDS.EXPENSE_VAT_INCLUDED]: VAT_INCLUDED.NO,
    // Note: EXPENSE_DATE field seems to not exist in Airtable for Team Leader expenses
    // [FIELDS.EXPENSE_DATE]: new Date().toISOString().split('T')[0],
    [FIELDS.EXPENSE_MONTH]: month,
    [FIELDS.EXPENSE_YEAR]: year,
    [FIELDS.EXPENSE_SOURCE]: SOURCE.AUTOMATIC,
    [FIELDS.EXPENSE_ID]: expenseId,
    [FIELDS.EXPENSE_ASSOCIATED_SALES]: saleIds
  };
  
  try {
    // Check if expense already exists
    const existingExpense = await getExpenseByExpenseId(expenseId);
    
    if (existingExpense) {
      logger.info('Updating existing Team Leader expense', {
        expenseId,
        oldAmount: existingExpense.amount,
        newAmount: roundedCommission,
        salesCount
      });
      
      await updateExpense(existingExpense.id, {
        fields: expenseFields
      });
      logger.info('Team Leader expense updated successfully', {
        expenseId,
        teamLeaderName,
        project,
        amount: roundedCommission
      });
    } else {
      logger.info('Creating new Team Leader expense', {
        expenseId,
        teamLeaderName,
        project,
        amount: roundedCommission,
        salesCount
      });
      
      await createExpense({
        fields: expenseFields
      });
      logger.info('Team Leader expense created successfully', {
        expenseId,
        teamLeaderName,
        project,
        amount: roundedCommission
      });
    }
  } catch (error) {
    logger.error('Failed to create/update Team Leader expense', {
      error: error.message,
      expenseId,
      teamLeaderName,
      project
    });
    throw error;
  }
}

